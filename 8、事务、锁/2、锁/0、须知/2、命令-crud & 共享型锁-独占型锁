库级命令：
        通过命令加的全局锁，通常是共享型锁，详见相应文件夹。

表级命令：
        通过命令加的表级锁，加的既可是共享型锁、也可是独占型锁，详见相应文件夹。

行级crud：
        执行简单的select读操作，并不会也不需要加锁！
                简单的SELECT语句是不会也不需要加锁的，它是利用MVCC中对事务的READ-VIEW快照实现的快照读（从而实现一致性读）。

        执行读操作只能这样对数据表中的某些行的索引上自动加上锁，来锁住相应的行：
                select ... lock in share mode;//会自动（先在表上加上意向共享锁）对读取的相应行的相应索引加共享型锁，来锁住相应的行。
                select ... for update;        //会自动（先在表上加上意向独占锁）对读取的相应行的相应索引加独占型锁，来锁住相应的行。
                todo:由于事务（含隐形事务）一提交，上述select加的行级锁就会释放，因此在使用时上述加锁的select语句通常用在手动事务中，
                     这样在手动事务期间，相应的行都是被加锁的，事务内、在上述select语句之后对相应行进行 插入、更新、删除 操作时，相
                     应的行在整个事务中都是不会被其他事务改变的，因为其他事务要删改相应的行需要先加上独占锁，但和相应行上的锁不兼容
                     而被阻塞！

        执行insert、update、delete写操作就会自动加锁，而且加的是独占锁！


        由上可知：
            简单的读操作并不会也不需要加锁！
            读操作时若加锁，可以是共享型锁，也可以是独占型锁。

            写操作，必须也一定会自动加锁！
            写操作时加的锁，一定是独占型锁。


*注意*：读写都是操作，而并非有什么读锁写锁。
     全局锁、表级锁、行级锁中的那些锁，就其名称而言均无是否兼容的判断价值，都并不是一个什么特别的锁，而只是在描述锁住的位置。
     看具体的库级、表级命令、行级读写操作的sql语句，才能确定加的是共享锁还是独占锁，而只有确定了是共享锁还是独占锁，才具有判断是否兼容的价值。
     （当然，共享锁、独占锁之间的兼容互斥，还是受到行级锁所锁住的范围的影响的，间隙锁就会让共享锁S、独占锁X的兼容互斥关系发生变化）
（完）
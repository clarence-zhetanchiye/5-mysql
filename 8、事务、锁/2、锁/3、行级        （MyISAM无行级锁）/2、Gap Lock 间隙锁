Gap Lock：间隙锁，锁定的是一个间隙、即尚不存在但可供后续新增进来的若干行数据，但是不包含间隙边界那一行，也即锁定的范围是左开右开区间( , )。
          它并不是一个什么特别的锁，而只是在描述锁住的位置。
          todo:间隙锁只存在于事务的可重复读隔离级别，目的是为了解决可重复读隔离级别下事务之间幻读的现象。


    关于讨论在数据表的某一索引树的间隙上加锁（也即所谓的间隙锁）：
    不论多个事务在这一间隙上进行的是读操作还是写操作、导致加的间隙锁是共享锁还是独占锁，那么共享锁S、独占锁X的兼容互斥规则都被颠覆，
它们的兼容互斥的各种情形如下：
    例如：
        数据表中有三行数据
        id     usr     hobby
        1       j       玩
        2       k       学
        4       p       问
    那么间隙就是id=3这一行。

    经过实验得知：
    间隙上加了读操作的独占锁，在这个间隙上再加读操作的共享锁（读取一行），并不会被阻塞。
    间隙上加了读操作的独占锁，在这个间隙上再加写操作的独占锁（删除一行），并不会被阻塞。
    间隙上加了读操作的独占锁，在这个间隙上再加写操作的独占锁（更新一行），并不会被阻塞。

    间隙上加了读操作的共享锁，在这个间隙上再加写操作的独占锁（插入一行），会被阻塞！！！！
    间隙上加了读操作的共享锁，在这个间隙上再加写操作的独占锁（更新一行），不会被阻塞。
    间隙上加了读操作的共享锁，在这个间隙上再加写操作的独占锁（删除一行），不会被阻塞。

    间隙上加了写操作的独占锁（删除一行），在这个间隙上再加写操作的独占锁（插入一行），会被阻塞！！！！
    间隙上加了写操作的独占锁（删除一行），在这个间隙上再加读操作的共享锁，不会被阻塞。
    间隙上加了写操作的独占锁（删除一行），在这个间隙上再加读操作的独占锁，不会被阻塞。
    间隙上加了写操作的独占锁（删除一行），在这个间隙上再加写操作的独占锁（删除一行），不会被阻塞。

    间隙上加了写操作的独占锁（更新一行），在这个间隙上再加写操作的独占锁（插入一行），会被阻塞！！！！
    间隙上加了写操作的独占锁（更新一行），在这个间隙上再加读操作的共享锁（读取一行），不会被阻塞。
    间隙上加了写操作的独占锁（更新一行），在这个间隙上再加读操作的独占锁（读取一行），不会被阻塞。
    间隙上加了写操作的独占锁（更新一行），在这个间隙上再加写操作的独占锁（删除一行），不会被阻塞。

    间隙上加了写操作的独占锁（新增一行），在这个间隙上再加读操作的共享锁（读取该行），会被阻塞！！！
    间隙上加了写操作的独占锁（新增一行），在这个间隙上再加读操作的独占锁（读取该行），会被阻塞！！！
    间隙上加了写操作的独占锁（新增一行），在这个间隙上再加写操作的独占锁（插入该行），会被阻塞！！！
    间隙上加了写操作的独占锁（新增一行），在这个间隙上再加写操作的独占锁（删除该行），会被阻塞！！！
    间隙上加了写操作的独占锁（新增一行），在这个间隙上再加写操作的独占锁（更新该行），会被阻塞！！！

todo:因此：
    可以这么说，关于讨论在数据表的某一索引的一个间隙上加锁（即所谓的间隙锁），不论多个事务在这一间隙上进行的是读操作还是写操作、导致加的间隙
 锁是共享锁还是独占锁，共享锁、独占锁都是兼容的！【这里的同一个间隙有两种情况，一种情况是被事务a加锁的间隙和被事务b加锁的间隙，间隙区间完全
 一样；另一种情况，被事务a加锁的间隙是被事务b加锁的间隙的子间隙】
    只有一种情况例外，就是事务a已经对该间隙加上了锁（不论是共享锁还是独占锁），另一个事务b要向这个间隙插入数据时，总是会被阻塞！或者反过来，
 事务a正在向该间隙插入数据（是写操作故显然加的独占锁）还未提交，则另一个事务b对该间隙不论是加共享锁还是独占锁，都会被阻塞！
    也即，间隙锁的目的只在于阻止间隙中被插入数据。之所以如此，是因为这样就已经能够很好地做到可重读隔离级别下，防止事务之间幻读现象的发生。

（todo:但正因为间隙锁的巨大兼容性，导致了死锁现象的时有发生！）

（完）
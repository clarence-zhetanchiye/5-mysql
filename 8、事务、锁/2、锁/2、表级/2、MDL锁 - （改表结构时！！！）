MDL锁是为了保证当前会话对表执行 crud 操作时，防止其他会话对这个表的结构做变更。
MDL锁不需要显示调用，会话对数据表进行操作时，会自动隐形地给这个表加上MDL锁，MDL锁在事务（含隐形事务）提交后才会被释放。

对一张表进行CRUD操作时，会隐形地加上MDL读锁；此时如果有其他线程要更改该表的结构（隐形地申请MDL写锁）将会被阻塞，直到MDL读锁被释放。
对一张表做结构变更操作时，会隐形地加上MDL写锁；此时如果有其他线程要执行CRUD操作（隐形地申请MDL读锁）就会被阻塞，直到MDL写锁被释放。

*注意* ：为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中是否有未提交的长事务（即还未释放对表加上的MDL读锁），若有
        则需要考虑 kill 掉这个长事务，然后再对表结构进行变更。
*注意* ：否则看这个例子
    首先，会话 A 执行crud语句，但该事务（含隐形事务）在下面几个步骤期间都没有提交，即一直未释放对该表加上的MDL读锁。
    然后，会话 B 也执行了crud语句，此时并不会阻塞，因为「读读」并不冲突。
    接着，会话 C 要修改表字段，此时由于线程 A 的事务并没有提交即MDL读锁尚未释放，因此这时线程C无法申请到MDL写锁，被阻塞。
    之后，会话 D 要执行crud语句，加入到申请MDL读锁的排队中，由于线程C阻塞，而申请MDL写锁的优先级高于申请MDL读锁，因此线程D也被迫阻塞。
    最后，如果此时有大量该表的 crud 语句的会话到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了！
因此，变更表结构之前，要等正在使用MDL读锁的事务完成，或kill掉这样的事务，迅速地变更完表结构（因为变更期间别的会话的crud语句会被阻塞）。


（完）
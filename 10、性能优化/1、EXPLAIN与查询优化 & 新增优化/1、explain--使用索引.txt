1、分析查询语句的语法：
    EXPLAIN SELECT···语句;    //其中的EXPLAIN也可以用DESCRIBE或简写为DESC，作用是一样的。

    示例：EXPLAIN SELECT * FROM softs;
    结果为：
    +----+-------------+-------+------+---------------+------+---------+------+------+-------+
    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
    +----+-------------+-------+------+---------------+------+---------+------+------+-------+
    |  1 | SIMPLE      | softs | ALL  | NULL          | NULL | NULL    | NULL |    3 |       |
    +----+-------------+-------+------+---------------+------+---------+------+------+-------+
    其中：
    1、table列：表示SELECT语句所查询的表名称；
    2、type列：查询数据使用的方式，效率由低到高分别有：ALL表示全表扫描、index（索引结构全扫描）、range（索引结构范围扫描）、
              ref（非唯一索引扫描，常是索引值有重复）、index merge（两个索引扫描，常见于sql中OR前后俩字段都是索引的情形）、
              eq_ref（唯一索引扫描）、const（结果只有一条的主键或唯一索引扫描）。

              在这些情况里，all 是最坏的情况，因为采用了全表扫描的方式。index 和 all 差不多，只不过 index 对索引表进行全扫描，这样做的好处是不再需要对数据进行排序，但是开销依然很大。所以，要尽量避免全表扫描和全索引扫描。
              range 表示采用了索引范围扫描，一般在 where 子句中使用 < 、>、in、between 等关键词，只检索给定范围的行，属于范围查找。从这一级别开始，索引的作用会越来越明显，因此我们需要尽量让 SQL 查询可以使用到 range 这一级别及以上的 type 访问方式。
              ref 类型表示采用了非唯一索引，或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。因为虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。
              eq_ref 类型是使用主键或唯一索引时产生的访问方式，通常使用在多表联查中。比如，对两张表进行联查，关联条件是两张表的 user_id 相等，且 user_id 是唯一索引，那么使用 EXPLAIN 进行执行计划查看的时候，type 就会显示 eq_ref。
              const 类型表示使用了主键或者唯一索引与常量值进行比较，比如 select name from product where id=1。
              需要说明的是 const 类型和 eq_ref 都使用了主键或唯一索引，不过这两个类型有所区别，const 是与常量进行比较，查询效率会更快，而 eq_ref 通常用于多表联查中

    3、possible_keys列：指出当前查询语句中可供使用的索引!!!
    4、key列：指出当前查询语句实际使用的索引，为null表示本次查询未使用索引!!!
    5、key_len：指出当前查询语句实际使用的索引的字节长度（可用于分析使用了多列索引中的哪些列）
    6、rows列：当前查询语句为了查询到结果数据而检测过的数据表的行数!!!
    7、extra列：值可能为
        Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候，这时不得不选择相应的排序算法进行，
                         甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。
        Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。
                         效率低，要避免这种问题的出现。特别地！如果临时表很大，超过了允许提供给临时表的最大内存空间（可以设置修改），
                         则临时表会存进磁盘中，这样效率就会很低！
        Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。
        Using index condition：说明对于类似 WHERE num>9 AND price=10 这种num和price是联合索引的，使用了索引下推的优化，即price=10
                               的判断是在扫描索引结构时就进行的，而非根据找到的num>9到聚簇索引中回表再来筛选price=10。

2、使用索引：实际生产中，上述分析语句常用来分析所使用的查询sql速度是否快，即是否合理使用了索引。


（完）
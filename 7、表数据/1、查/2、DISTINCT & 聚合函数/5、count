按照性能排序：COUNT(*) = COUNT(1) > COUNT(主键) > COUNT(一般非索引字段)

函数解释：------------
COUNT()这个聚合函数的参数可以是字段名，也可以是其他任意表达式；作用是统计符合查询条件的记录中，入参不为 NULL 的记录有多少个。
        COUNT(1):待查的数据表中 1 这个表达式不为 NULL 共有多少行；由于 1 永远都不会是 NULL ，因此其实就是计算数据表中共有多少行数据。
        COUNT(*)：会被mysql转化为COUNT(0)来处理，和COUNT(1)是一样的。
        COUNT(字段)：效率最差，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个索引！

原理过程：------------
    mysql的 server 层会循环向 InnoDB 读取一条记录，如果 COUNT 函数指定的参数不为 NULL，那么就会将变量 server 层的变量 count 加 1，
直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端，作为COUNT()的结果。
    如果能通过读取索引达到目的，mysql会优先读取非聚簇索引，因为非聚簇索引的叶子节点保存的数据比聚簇索引少，因此I/O更快，如果非聚簇索引里
有索引所占空间更小的，mysql还会选择所占空间更小的索引去遍历，速度会更快；如果COUNT()的入参不是具体字段，则意味着扫描索引结构的过程中，只需
扫描到而无需读取字段值，速度会更快。
    因此性能上 COUNT(*) = COUNT(1) > COUNT(主键) > COUNT(一般非索引字段)


如何对超大表统计行数-------------
    如果对一张大表经常用 count(*) 来做统计，其实是很不好的。实验证明对于1200万行数据的表，查一次COUNT(*)耗时5秒。

方式一，近似值
    如果你的业务对于统计个数不需要很精确，比如搜索引擎在搜索关键词的时候，给出的搜索结果条数是一个大概值。
    可以执行 EXPLAIN SELECT COUNT() FROM tab_name，得到的 rows 字段值就是 EXPLAIN 命令对表 tab_name 记录的估算值。
    因为执行 EXPLAIN 命令效率是很高的，因为它并不会真正的去查询。

方式二，额外表保存计数值
    如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。
    当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。

（完）